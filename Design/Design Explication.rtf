{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;\csgray\c100000;}
\margl1440\margr1440\vieww18720\viewh13340\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Design Explication for Kevin\'92s Mazify!\
Kai Wen Wang (kaiwenw1)\
\
	The problem I am solving is generating a maze out of any image, preserving the salient points in such a way that the user can determine the shape of the image from looking at the maze. At first, I attempted to canny filter images to detect all salient edges of the image. Then making a maze from the edges. And finally using a maze solver to generate a solution. However, after implementing the canny filters, it became clearer that this was not a very feasible approach for 112, as it would involve complex algorithms such as cellular neural networks (Wan et al., 2010). \
	Thus, I took on another approach by following the proven Island-Bridges model on the 112 website (I altered the code greatly). Then through recursive backtracking to generate valid bridges (sourced from Wikipedia Maze Generation page), and using the mazeSolver backtracking model of mazeSolver, I constructed a working model of maze generation and solving. I used data structures effectively, using dictionaries to store the islands corresponding to each island location, and storing ghosts (from Pacman) corresponding to their color. This meant I could loop through the islands and ghosts while keeping track of their properties. Another use of data structures was storing bridges. Since the ordering of the two ends of the bridge does not matter (in fact it\'92s unwanted), I used a set of two tuples to denote bridges (then kept those sets in a list, to create a list of bridges). An application of flood fill was also employed to determine all the connected blocks in the image (flood fill similar colors).\
	(Note: all image processing was done with Pillow)\
	Of course, the image had to be processed to allow for these algorithms to work. Thanks to the help of Tim Brooks, a former 112 TA, I obtained some slides from CMU\'92s photography class. Following videos from Youtube ((ML16.1) K-means clustering (Part 1 & 2) by mathematicalmonk), I implemented the algorithm to reasonable accuracy (although not to convergence, I set the iteration index to be reasonably high for good processing speed at reasonable accuracy).\
	To draw the mazes in Tkinter, I did not draw using Tkinter itself. Rather, I destructively modified the image using Pillow, changing the pixels of the mazes to red. Then I used Tkinter to simply show the image. I updated the image every time Pacman moved. This was expectedly expensive, and although I tried to speed it up by using delta graphics (drawing one bridge at a time), it did not help significantly and made my code more confusing. Thus, I created an illusion of speed by varying Pacman\'92s speed according to its relative location to islands (when it is close to islands, it would slow down to make transitions fluent but when Pacman is moving in straight lines, it would move at 2x speed). This change in speed is not noticeable to the eye without close inspection and gives the perception of fluency. \
	The background was similar to the game. The difference being, I first solved the maze through recursive backtracking, and then told the AI Pacman to follow the solved paths. The ghosts employed Markov chains so that the probability of going in circles is nearly 0 (this forces them to go straight). \
	I am very proud of what I have accomplished, and what I am capable of achieving now after 112 (especially after taking a different approach 1 week into the project, I still created a reasonably robust and unique program, using a lot of interesting algorithms). One thing I\'92m especially proud of is that almost all the image processing/algorithms are written organically by myself (the only significant one not written by me is resizing images), using a preliminary module Pillow for pixel-by-pixel analyses.\
	As for user interface, I included a background that is catchy, engaging and not overly distracting. The user still focuses on the prompts at the centre of the screen while a single Pacman makes his way from the top-left corner to the bottom-right corner. However, this gave my program a dark ambiance, so I needed to use bright text. For it to be easier on the eyes, when reading I placed grey (not white) text on black rectangles, as white is too bright for the eyes (stimulates all cones and high intensity). I also made the text as uncluttered as possible to increase readibility (especially of the help screen). Finally, I established this dark/grey theme throughout the program. \
	I did have more ambitious goals, that were incidentally mentioned during the Dec 6 peer discussions. Namely, I wanted to incorporate the capability of using images with multiple colors, or disconnected pieces, and the connection between each piece would be a key/portal system (which would make for a much more game-oriented TP rather than an algorithm oriented TP like this one). I could not achieve them because of the time restraint but they\'92re worth thinking and reflecting about for future projects. Nevertheless, this TP journey was truly a unique one. As my first significant CS project, I am very proud of what I\'92ve accomplished. \
	I could not have achieved what I\'92ve achieved without the support of Professor David Kosbie, my mentor Jessie Li, former 112 TA Tim Brooks, all the wonderful 112 TAs during OHs and Piazza posts, and all my fellow peers who took the time to critique and comment on my project. A huge thank you to everyone. I\'92m very thankful for all the support I\'92ve received.}